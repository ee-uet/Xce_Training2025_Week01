## PROBLEM: Non-Restoring 32-bit Unsigned Division (RISC-V Assembly)

## Problem  
Implement the **non-restoring division algorithm** in RISC-V assembly language to divide two unsigned 32-bit integers. The program computes both the **quotient** and **remainder** without using the built-in division instruction.

---

## Approach  
- Initialize registers:
  - `x1`: Dividend  
  - `x2`: Quotient (result)  
  - `x3`: Remainder (intermediate & final)  
  - `x4`: Divisor  
  - `x5`: Bit counter (31 → 0)  

- Perform **bit-by-bit division** for 32 iterations:
  1. Shift the remainder left and bring in the next bit of the dividend.  
  2. If remainder ≥ 0 → subtract divisor.  
  3. If remainder < 0 → add divisor back.  
  4. Set the quotient bit accordingly.  

- At the end, if remainder < 0, adjust it by adding divisor.  
- Store result in `tohost` for Spike simulator output.

---

## How to Run

Spike (the RISC-V ISA Simulator) was installed using the manual.  
For compilation, the `riscv64-unknown-elf-*` toolchain was used.

**`link.ld` linker script** provided in the manual was used along with the following **Makefile**:
```
# Program name
PROG = filename


# Tools
AS = riscv64-unknown-elf-as
LD = riscv64-unknown-elf-ld
SPIKE = spike
# Default target
all: $(PROG).elf

# Assemble and link
$(PROG).elf: $(PROG).s link.ld
        $(AS) -o $(PROG).o $(PROG).s
        $(LD) -T link.ld -o $@ $(PROG).o

# Run with Spike (bare-metal)
run: $(PROG).elf
        $(SPIKE) $(PROG).elf

# Clean build files
clean:
        rm -f *.o *.elf

.PHONY: all run clean
```
- To run assembly code using spike
  
  First of all, write the name of your file in makefile
  `PROG = filename`. 
  Then run these commands in terminal
  ```
  make
  make run
  spike -d --log-commits filename.elf
  ```
- To get the assembly file built by toolchain, run this command.
  ```
  riscv64-linux-gnu-gcc -S program.c -o program_toolchain.s

# Examples
- Example 1
  
Input: `Dividend = 100`, `Divisor = 7`

Output: `Quotient = 14`, `Remainder = 2`

- Example 2

Input: `Dividend = 50`, `Divisor = 5`

Output: `Quotient = 10`, `Remainder = 0`

--- 

## Known Limitations

- Only supports unsigned integers.
- Division by zero is not handled.
- Requires a 32-bit dividend (higher bit-length modifications needed for 64-bit).

## Assembly File generated by toolchain

My Code:

- Keeps dividend, divisor, quotient, remainder in registers → fewer memory ops.
- Uses blt directly for comparison (fast).
- Cleaner loop control with addi decrement and bge.

Compiler Code:
- Slower
- More area usage
- Redundant instructions (sign extensions)

`My handwritten code is more optimized in terms of performance, size, and register usage.`

## Sources & AI Usage

- Algorithm understanding - `ChatGPT`.
- Command to get assembly file built by toolchain - `ChatGPT`.
- Got logical errors fixed - `ChatGPT`.
  