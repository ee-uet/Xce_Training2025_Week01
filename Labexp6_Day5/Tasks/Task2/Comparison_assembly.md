# Assembly Code Comparison: x86-64 vs RISC-V

## Overview

This document compares two assembly implementations of a bit manipulation program that sets or clears a specific bit in a 32-bit number. One implementation is in x86-64 assembly (generated by GCC from C code), and the other is hand-written RISC-V assembly.

## Program Functionality

Both programs implement the same core functionality:
- Take a 32-bit number as input
- Modify a specific bit at a given position
- Set the bit (OR operation) or clear the bit (AND with inverted mask)
- Return the modified number

## Architecture Comparison

### x86-64 Implementation (Task2_C.s)

**Key Characteristics:**
- **Architecture**: Complex Instruction Set Computer (CISC)
- **Generated by**: GCC compiler from C source code
- **Register Usage**: Uses stack-based parameter passing and local variables
- **Function Structure**: Contains both `bit_modify` function and `main` function

**Code Structure:**
```assembly
bit_modify:
    # Function prologue with stack frame setup
    pushq   %rbp
    movq    %rsp, %rbp
    
    # Parameter storage on stack
    movl    %edi, -20(%rbp)    # number
    movl    %esi, -24(%rbp)    # position
    movl    %edx, -28(%rbp)    # operation
    
    # Bit mask creation
    movl    -24(%rbp), %eax
    movl    $1, %edx
    sall    %cl, %edx          # mask = 1 << position
    
    # Conditional branching and bit operations
    cmpl    $1, -28(%rbp)
    jne     .L2
    orl     %eax, -20(%rbp)    # Set bit
    jmp     .L3
.L2:
    notl    %eax
    andl    %eax, -20(%rbp)    # Clear bit
```

### RISC-V Implementation (Task2_hand.s)

**Key Characteristics:**
- **Architecture**: Reduced Instruction Set Computer (RISC)
- **Hand-written**: Optimized assembly code
- **Register Usage**: Direct register-to-register operations
- **Execution Model**: Single program with inline logic

**Code Structure:**
```assembly
_start:
    li a0, 0x12345678      # Test number (direct)
    li a1, 5               # Bit position (direct)
    li a2, 1               # Operation flag (direct)
    
    # Bit mask creation
    li t0, 1               
    sll t0, t0, a1         # mask = 1 << position
    
    # Conditional branching
    beq a2, x0, clear_bit  
    
    # Set bit
    or a0, a0, t0          # Direct register operation
    j done
    
clear_bit:
    not t0, t0             # Invert mask
    and a0, a0, t0         # Clear bit
```

## Detailed Comparison

### 1. Code Complexity and Size

| Aspect            | x86-64                       | RISC-V               |
|-------------------|------------------------------|----------------------|
| **Lines of Code** | ~60 lines                    | ~35 lines            |
| **Functions**     | 2 (bit_modify + main)        | 1 (inline program)   |
| **Stack Usage**   | Heavy stack frame management | Minimal stack usage  |
| **Complexity**    | High (compiler-generated)    | Low (hand-optimized) |

### 2. Register Usage

**x86-64:**
- Uses complex stack-based parameter passing
- Local variables stored at negative stack offsets
- Register names: `%rdi`, `%rsi`, `%rdx`, `%eax`, `%ecx`
- Requires explicit stack frame setup/teardown

**RISC-V:**
- Direct register-to-register operations
- Function arguments in `a0`, `a1`, `a2` registers
- Temporary registers `t0`, `t1` for intermediate calculations
- No stack frame overhead for this simple operation

### 3. Instruction Efficiency

**x86-64:**
- Variable-length instructions
- Complex addressing modes (e.g., `-20(%rbp)`)
- Fewer total instructions due to CISC nature
- Memory-intensive operations

**RISC-V:**
- Fixed-length 32-bit instructions
- Simple, uniform instruction format
- More instructions required but simpler execution
- Register-centric design

### 4. Performance Characteristics

| Factor                     | x86-64                          | RISC-V                      |
|----------------------------|---------------------------------|-----------------------------|
| **Function Call Overhead** | High (stack frame)              | None (inline)               |
| **Memory Access**          | Frequent stack access           | Minimal memory access       |
| **Pipeline Efficiency**    | Variable (complex instructions) | High (uniform instructions) |
| **Code Density**           | Higher (CISC)                   | Lower (RISC)                |

### 5. Bit Manipulation Logic

Both implementations use identical logical approach:

**Bit Setting (OR operation):**
- Create mask: `mask = 1 << position`
- Apply mask: `result = number | mask`

**Bit Clearing (AND operation):**
- Create mask: `mask = 1 << position`
- Invert mask: `mask = ~mask`
- Apply mask: `result = number & mask`

### 6. Control Flow

**x86-64:**
- Uses `cmpl` for comparison
- Conditional jump with `jne` (jump if not equal)
- Unconditional jump with `jmp`

**RISC-V:**
- Uses `beq` for branch if equal
- Direct comparison with zero register `x0`
- Unconditional jump with `j`

### 7. Test Data

**x86-64:**
- Number: `305419896` (0x12345678 in decimal)
- Position: `5`
- Operation: `1` (set bit)

**RISC-V:**
- Number: `0x12345678` (direct hexadecimal)
- Position: `5`
- Operation: `1` (set bit)

## Architectural Philosophy Differences

### x86-64 (CISC)
- **Design Goal**: Minimize number of instructions
- **Trade-off**: Complex instructions, variable timing
- **Optimization**: Compiler handles complexity
- **Memory**: Efficient use of memory addressing modes

### RISC-V (RISC)
- **Design Goal**: Simplify instruction execution
- **Trade-off**: More instructions, predictable timing
- **Optimization**: Hand-tuning more feasible
- **Registers**: Abundant register set reduces memory traffic

## Conclusion

The comparison reveals fundamental differences between CISC and RISC architectures:

1. **x86-64 version** demonstrates compiler-generated code with heavy stack usage, complex addressing, and function call overhead, but achieves the same result with fewer assembly instructions.

2. **RISC-V version** shows the elegance of RISC design with simple, uniform instructions, direct register usage, and predictable execution patterns.

3. **Performance implications**: The RISC-V version would likely execute faster due to reduced memory access and simpler instruction pipeline, while the x86-64 version achieves better code density.

4. **Development perspective**: The RISC-V code is more readable and maintainable, while the x86-64 code benefits from advanced compiler optimizations.

Both approaches solve the same problem effectively, but they represent different philosophical approaches to processor design and code generation.
